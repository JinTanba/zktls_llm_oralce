"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchWitnessListForClaim = void 0;
var sign_data_1 = require("./sign-data");
var ethers_1 = require("ethers");
/**
 * Compute the list of witnesses that need to be
 * contacted for a claim
 *
 * @param state current beacon state
 * @param identifier params of the claim
 * @param timestampS timestamp of the claim
 */
function fetchWitnessListForClaim(_a, params, timestampS) {
    var witnesses = _a.witnesses, witnessesRequiredForClaim = _a.witnessesRequiredForClaim, epoch = _a.epoch;
    var identifier = typeof params === 'string'
        ? params
        : (0, sign_data_1.hashClaimInfo)(params);
    // include the epoch and
    // witnessesRequiredForClaim in the hash
    // so the same claim can be made multiple times
    // with different witnesses
    var completeInput = [
        identifier,
        epoch.toString(),
        witnessesRequiredForClaim.toString(),
        timestampS.toString(),
    ]
        .join('\n');
    var completeHashStr = ethers_1.ethers.utils.keccak256(Buffer.from(completeInput, 'utf-8'));
    var completeHash = Buffer.from(completeHashStr.slice(2), 'hex');
    var witnessesLeft = __spreadArray([], witnesses, true);
    var selectedWitnesses = [];
    // we'll use 32 bits of the hash to select
    // each witness
    var byteOffset = 0;
    for (var i = 0; i < witnessesRequiredForClaim; i++) {
        var randomSeed = completeHash.readUint32BE(byteOffset);
        var witnessIndex = randomSeed % witnessesLeft.length;
        var witness = witnessesLeft[witnessIndex];
        selectedWitnesses.push(witness);
        // Remove the selected witness from the list of witnesses left
        witnessesLeft[witnessIndex] = witnessesLeft[witnessesLeft.length - 1];
        witnessesLeft.pop();
        byteOffset = (byteOffset + 4) % completeHash.length;
    }
    return selectedWitnesses;
}
exports.fetchWitnessListForClaim = fetchWitnessListForClaim;
//# sourceMappingURL=beacon.js.map
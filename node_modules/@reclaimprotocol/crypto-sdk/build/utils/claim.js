"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverSignersOfSignedClaim = exports.assertValidSignedClaim = exports.verifyEncryptedClaims = exports.encryptClaimProof = void 0;
var ethers_1 = require("ethers");
var buffer_json_1 = require("./buffer-json");
var redactions_1 = require("./redactions");
var sign_data_1 = require("./sign-data");
var signatures_1 = require("./signatures");
var data_1 = require("./data");
/**
 * Encrypts data using recipient's public key and sender's private key.
 * @param publicKey - Recipient public key in raw (un-hexed) form.
 * @param privateKey - Sender's private key in raw (un-hexed) form.
 * @param data - claim proof to encrypt
 */
function encryptClaimProof(publicKey, privateKey, data) {
    var serialised = Buffer.from(JSON.stringify(data, buffer_json_1.BufferJSON.replacer));
    return (0, data_1.encryptData)(publicKey, privateKey, serialised);
}
exports.encryptClaimProof = encryptClaimProof;
/**
 * Call to verify that the claims are proven by the encrypted proofs
 * @param claims the claims to verify
 * @param encryptedProofs encrypted proofs of the claims
 * @param privateKey private part of the communication key, must have been used
 * to encrypt the "encryptedProofs"
 */
function verifyEncryptedClaims(claims, encryptedProofs, privateKey) {
    var revealedClaims = {};
    // claims we have not found a proof for
    var claimsMissing = new Set(claims.map(function (c) { return c.identifier; }));
    var _loop_1 = function (identifier, enc) {
        var claim = claims
            .find(function (c) { return c.identifier === identifier; });
        if (!claim) {
            throw new Error('Claim not found');
        }
        // 1. check the data decrypts successfully
        var decryped = (0, data_1.decryptData)(privateKey, claim.ownerPublicKey, enc);
        // 2. check the data is valid JSON
        var proof = JSON.parse(decryped.toString(), buffer_json_1.BufferJSON.reviver);
        // 3. check the claim parameters contained original link
        // match the ones decrypted
        if (!(0, redactions_1.isRedactionCongruent)(claim.redactedParameters, proof.parameters)) {
            throw new Error("Claim parameters do not match for \"".concat(identifier, "\", redacted=\"").concat(claim.redactedParameters, "\", decrypted=\"").concat(proof.parameters, "\""));
        }
        assertValidSignedClaim({
            claim: __assign(__assign({}, claim), { parameters: proof.parameters, owner: signatures_1.signatures.getAddress(claim.ownerPublicKey) }),
            signatures: proof.signatures
        }, claim.witnessAddresses);
        claimsMissing.delete(identifier);
        revealedClaims[identifier] = proof;
    };
    // go through all encrypted proofs and decrypt them
    // check if the decrypted proof matches the claim
    for (var _i = 0, encryptedProofs_1 = encryptedProofs; _i < encryptedProofs_1.length; _i++) {
        var _a = encryptedProofs_1[_i], identifier = _a.identifier, enc = _a.enc;
        _loop_1(identifier, enc);
    }
    // 7. if there are any claims left, that did not have a proof
    // throw an error, because we expected all claims to be proven
    if (claimsMissing.size) {
        var missing = claims.map(function (c) { return c.identifier; }).join(', ');
        throw new Error("Not all claims were proven: ".concat(missing));
    }
    return revealedClaims;
}
exports.verifyEncryptedClaims = verifyEncryptedClaims;
/**
 * Asserts that the claim is signed by the expected witnesses
 * @param claim
 * @param expectedWitnessAddresses
 */
function assertValidSignedClaim(claim, expectedWitnessAddresses) {
    var witnessAddresses = recoverSignersOfSignedClaim(claim);
    // set of witnesses whose signatures we've not seen
    var witnessesNotSeen = new Set(expectedWitnessAddresses);
    for (var _i = 0, witnessAddresses_1 = witnessAddresses; _i < witnessAddresses_1.length; _i++) {
        var witness = witnessAddresses_1[_i];
        if (witnessesNotSeen.has(witness)) {
            witnessesNotSeen.delete(witness);
        }
    }
    // check if all witnesses have signed
    if (witnessesNotSeen.size > 0) {
        throw new Error("Missing signatures from ".concat(expectedWitnessAddresses.join(', ')));
    }
}
exports.assertValidSignedClaim = assertValidSignedClaim;
/** recovers the addresses of those that signed the claim */
function recoverSignersOfSignedClaim(_a) {
    var claim = _a.claim, signatures = _a.signatures;
    var dataStr = (0, sign_data_1.createSignDataForClaim)(__assign({}, claim));
    return signatures.map(function (signature) { return (ethers_1.utils.verifyMessage(dataStr, signature).toLowerCase()); });
}
exports.recoverSignersOfSignedClaim = recoverSignersOfSignedClaim;
//# sourceMappingURL=claim.js.map
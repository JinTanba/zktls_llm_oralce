"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptData = exports.encryptData = void 0;
var crypto_1 = require("crypto");
var ethers_1 = require("ethers");
var utils_1 = require("ethers/lib/utils");
var hkdf = require("futoin-hkdf");
var AUTH_TAG_LENGTH = 16;
/**
 * Encrypts data using recipient's public key and sender's private key.
 * @param {Uint8Array} publicKey - Recipient public key in raw (un-hexed) form.
 * @param {Uint8Array} privateKey - Sender's private key in raw (un-hexed) form.
 * @param {Uint8Array} data - serialized data to encrypt
 */
function encryptData(publicKey, privateKey, data) {
    var _a = getKeyAndSalt(publicKey, privateKey), key = _a.key, salt = _a.salt;
    var cipher = (0, crypto_1.createCipheriv)('aes-256-gcm', key, salt, { authTagLength: AUTH_TAG_LENGTH });
    return Buffer.concat([
        cipher.update(data),
        cipher.final(),
        cipher.getAuthTag()
    ]);
}
exports.encryptData = encryptData;
/**
 * Decrypts data using sender's public key and recipient's private key.
 * @param {Uint8Array} privateKey - Recipient's private key in raw (un-hexed) form.
 * @param {Uint8Array} publicKey -Sender's public key in raw (un-hexed) form.
 * @param {Uint8Array} ciphertext - encrypted data
 */
/**
 * Decrypts data using sender's public key and recipient's private key.
 * @param {Uint8Array} privateKey - Recipient's private key in raw (un-hexed) form.
 * @param {Uint8Array} publicKey -Sender's public key in raw (un-hexed) form.
 * @param {Uint8Array} ciphertext - encrypted data
 */
function decryptData(privateKey, publicKey, ciphertext) {
    var _a = getKeyAndSalt(publicKey, privateKey), key = _a.key, salt = _a.salt;
    var decipher = (0, crypto_1.createDecipheriv)('aes-256-gcm', key, salt, { authTagLength: AUTH_TAG_LENGTH });
    decipher.setAuthTag(ciphertext.subarray(ciphertext.length - AUTH_TAG_LENGTH));
    ciphertext = ciphertext.subarray(0, ciphertext.length - AUTH_TAG_LENGTH);
    return Buffer.concat([
        decipher.update(ciphertext),
        decipher.final()
    ]);
}
exports.decryptData = decryptData;
function getKeyAndSalt(publicKey, privateKey) {
    var sharedSecret = Buffer.from(ethers_1.utils.arrayify(new utils_1.SigningKey(privateKey).computeSharedSecret(publicKey)));
    var key = hkdf(sharedSecret, 32, { salt: 'reclaim-key' });
    var salt = hkdf(sharedSecret, 12, { salt: 'reclaim-salt' });
    return { key: key, salt: salt };
}
//# sourceMappingURL=data.js.map